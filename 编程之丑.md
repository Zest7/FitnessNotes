了解一些编程的经典丑陋方式，也是为了更好的代码规范

# 1.命名

## 不准确的命名

好的类，函数名应当从名字就能看出是做啥的

例如processChapter这样的命名，“处理章节”就很抽象让人很难理解，因为处理的方式有很多种。

假设，这段代码做的就是把一个章节的翻译状态改成翻译中

那么应该如何命名？changeChapterToTranslating？

好的命名应当描述意图而不是具体细节

改成翻译中，startTranslation

## 用技术术语命名

例如booklist，如果接口的方法改变了呢？**接口是稳定的，而实现是易变的**

### 用业务语言写代码

例如xxxuid 实际uid表示什么含义，可能是reviewerUserId

最好单位有统一的要求

# 2.英文的使用

最低限度是写出来的代码要像是用英语在表达

违反语法规则的命名completedTranslate 不是一个动宾结构，就会很怪

不准确的英语词汇。例如auditStatus，和reviewStatus

## 个人感觉

写好命名其实很难，只能说了解基本规范，让人看着舒服就行。就像一篇错别字满天飞的文章，很难让人觉得好。

毕竟面试很多人看你写代码就看命名规范，也影响以后工作他人的态度想法。

有必要了解经典错误，平时多留意一下，但是也不能本末倒置了。

# 3.重复代码

简单来讲，重复的代码不要cv，而是要提取出来方便继续扩展

但是怎么样去发现重复本身并不容易，文中举了几个例子

## 个人感觉

这个还需要经验，需要案例的累计，只能说尽量有这种意识吧

# 4~6.长函数，大类，长参数列表

## 函数

作者提出一个函数的长度不应该超过20行

如果把规则定的太松，会没有约束力，定的太窄实现起来又过于困难

```xml
<module name="MethodLength">
　　    <property name="tokens" value="METHOD_DEF"/>
　　    <property name="max" value="20"/>
　　    <property name="countEmpty" value="false"/>
</module>
```

**一个好的程序员面对代码库时要有不同尺度的观察能力，看设计时，要能够高屋建瓴，看代码时，要能细致入微**。

性能不应该做为唯一的考核标准，可维护性也很重要

很多长函数的产生是对思维逻辑的罗列，第一步，第二步，第x步这样子

解决的方法也很简单，就是拆分。

## 类

产生大类的主要原因是职责不单一；字段未分组

职责不单一比较好理解，拆分也比较简单，就按照职责来拆分就好了

字段分组就是一个类，字段过多则按照划分标准来区分咯

## 参数

将长参数封装成对象

只是把一个参数列表封装成一个类，然后，用到这些参数的时候，还需要把它们一个个取出来，这会不会是多此一举呢？

我个人的理解是，相当于分层了，直接调用更底层的代码，屏蔽了细节，修改和复用也更加容易

告别标记参数，因为太多标记很容易将整个项目混乱，有时候甚至将其拆分成两个方法。（但是这样复用性不会变差么？）

## 个人感受

这几个章节都在讲，各个维度都不要弄的过于长，省的难以维护。以及一部分拆分，感觉挺难的，到底如何去拆分。

关于过早优化，过早优化会带来的人力成本等提升。

所以，应当挑选那种，成本很低的好习惯去学习，一些增加成本美化代码结构的按需求添加。

那目前来看就是，命名规范，函数类啥的尽量不要写太长，拆分一下。好像对于实践指导意义不是很大，只能说理论优先了。

# 7.滥用控制语句

一堆for，if缩进啥的容易让代码可读性下降

文中通过拆分函数，卫语句来简化了缩进层级。

```
if(a)
{
	if(b)
	{
	  xxx
	}
}
可以变成
if(！a)return
if(!b)return
xxx
```

else也被定义为一种坏味道的代码，代码分支过多容易让人难以理解

也可以通过卫语句的方式来消除

以多态取代条件表达式，文中举了一个例子，不同用户不同商品的折扣问题。

switch 其实就是一堆“ if..else” 的简化写法，二者是等价的

圈复杂度，圈复杂度越高，代码越复杂，理解和维护的成本就越高。在圈复杂度的判定中，循环和选择语句占有重要的地位。

## 个人理解

卫语句确实有时候有效

多态会不会反而更加复杂了？还是说我现在没理解到位呢？

# 8.缺乏封装

在程序设计中，一个重要的观念就是封装，将零散的代码封装成一个又一个可复用的模块。任何一个程序员都会认同封装的价值，但是，具体到写代码时，每个人对于封装的理解程度却天差地别，造成的结果就是：写代码的人认为自己提供了封装，但实际上，我们还是看到许多的代码散落在那里

```
String name = book.getAuthor().getName();
```

这样的代码就是不合理的，知道作者的名字需要拿到作者所有信息

我们需要隐藏委托关系

```
class Book {

　　  ...

　　  public String getAuthorName() {
　　    return this.author.getName();
　　  }

　　  ...

　　}

　　String name = book.getAuthorName();
```

正常写代码需要少暴露细节，迪米特法则（最少知识原则）

这样做会不会导致太多简单封装呢？可能会有的

需要这样我们应该考虑的问题是类应该提供哪些行为，而非简简单单地把数据换一种形式呈现出来。例如：有提供获取作者年龄的接口，但是没有罗列电话号，年龄等。

使用对象取代基本对象，例如对于价格这个变量，定义一个类

```
class Price {

　　  private long price;

　　  public Price(final double price) {
　　    if (price <= 0) {
　　      throw new IllegalArgumentException("Price should be positive");
　　    }
　　    this.price = price;
　　  }
　　}
```

这样就不同重复判断是否满足约束条件

基本的设计原则：组合优于继承

# 9.可变的数据

相比与读数据，修改是一个更危险的操作

比可变数据更可怕的是，不可控的变化

有时候，函数不需要set方法，而是隐式的给一个approve函数，让修改是可控的

## 我的想法

有时候，我都是单纯的直接给出get/set方法，可能是默认有所有权限？在正常的mvc架构中，我感觉数据层就是应该提供所有操作的可能阿，我不对外暴露这个操作的接口就行了，有这个方法不用也可以。

但是转念想一想，如果不是这种mvc架构，而是一个工具类啥的，别人直接修改某个类的变量，直接让其不可控，岂不是很危险？所以其实是要看需求的

# 10.变量声明和赋值分离

变量初始化和业务处理混在一起，某种程度上也会导致代码不清晰

变量的声明和初始化最好一次性完成，如果业务逻辑不需要修改，**在能够使用 final 的地方尽量使用 final**

```
final CreateEpubResponse response = createEpub(request);

　　final EpubStatus status = toEpubStatus(response);

　　private EpubStatus toEpubStatus(final CreateEpubResponse response) {
　　  if (response.getCode() == 201) {
　　    return EpubStatus.CREATED;
　　  }
　　  return EpubStatus.TO_CREATE;
　　}
```

同理的集合的初始化

```
List<Permission> permissions = List.of(

　　  Permission.BOOK_READ,

　　  Permission.BOOK_WRITE

　　);
```

# 11.依赖混乱

# 12.不一致的代码

枚举值的不一致

例如：A，B_only,ALL  可能存在意义不明，忽略了枚举值整体扮演的形式

方案的不一致

例如，对于判空，使用Guava，Apache等不同的方案可能会导致不一致，解决方案就是团队要事先定好规则。

代码层级不一致

例如：第一句：去浇花 第二句：浇花的具体细节



如何测试一个私有方法，

1.使用反射

2.调整分离度，在公开方法里面测试

# 13.使用新的代码风格

为了简化代码提出了很多新特性、

例如Optional用来判空

函数式编程

函数式编程的一个重要洞见就是，大部分操作都可以归结成列表转换，其中，最核心的列表转换就是 map、filter 和 reduce。

## 我的想法

太新的特性不被接受怎么办？

还是要看稳定版本，例如java的新特性是肯定可以用的了，java17新特性这种就不要考虑了

# 14.代码审评

建议是多审评

# 15.新需求破坏了代码

谨慎对待接口和实体的变动，最好是能够向上兼容