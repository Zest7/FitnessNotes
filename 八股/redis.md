# redis数据结构

redis的key是二进制安全的，也就是从字符串，整数到一整张图片都是可以的。

redis的字典是通过两个hash来实现的，[Redis 源码解析 4：字典 dict - 小新是也 - 博客园](https://www.cnblogs.com/chenchuxin/p/14191156.html)

以下数据结构是指的value的数据结构

String 动态字符串，int ：共享session信息，分布式锁，缓存对象

list 双向链表，压缩列表

set 哈希：聚合场景，比如点赞，共同关注

sortset 跳表和哈希：排序场景排行榜，姓名排序

hash 哈希和压缩列表

bitmap 字节数组：用于签到判断

geo

# redis持久化

redis持久化主要通过AOF和RDB日志

## AOF

仅针对写操作，写完之后写入AOF。

好处是不会阻塞操作，坏处是可能阻塞下一个，以及还没写入磁盘的话会丢失。

为了减少开销，AOF会先写入缓存，然后回写到磁盘，回写策略有三，总是，每秒，不回写。性能和安全的平衡。

AOF文件太大会触发AOF重写（百分比 默认100% 超过两倍的时候重写 0不重写，最低文件大小），

通过AOF恢复数据的本质是一条一条的执行命令所以可能会很慢

​	

## RDB

RDB是记录redis数据的二进制内容

一般在redis服务器启动的时候加载一次，然后根据配置执行save操作。

例如：

900 1

300 10 

60 1000        在90秒内修改了一次，在300秒内修改了10次

复制时候的写时复制：RDB会创建一个子线程，从主线程复制一份（页为单位）。但是如果主现场这时候修改了内容，RDB是感知不到的，只能等下次save的时候再存进去。



redis 4.0之后可以混合存储

# redis过期淘汰

## 过期淘汰策略

过期是指需要给键值对设定过期时间

可以在设定key的时候，或者set 键值对的时候设定  set key value ex/px 100  (ex是秒，px是毫秒)

过期之后会将key放入过期字典，redis查询数据的时候会先查询是否过期，没过期就正常查询，过期则返回错误

三种过期策略：

定时删除：设置过期时间的时候，创建定时任务，删除key/value。对内存友好，但是频繁操作cpu。

惰性删除：每次查询的时候，判断一下，如果时间戳已经过期则删除。对cpu友好，但是占用内存。

定期删除：每过一段时间取出一部分key进行检查，过期则删除

redis默认是采用惰性删除+定期删除：默认是一秒钟定期10次，然后每次抽20个，如果重复次数大于

## 内存淘汰策略

内存淘汰是redis超过了最大运行内存，需要删除一些key

不淘汰

淘汰已过期中最早的 ttl

（以下三种还分为在过期的key中和全部的key）

random随机淘汰 

lru最久没使用：redis的lru是一种近似的lru，原本的lru是通过一个链表时间最早的在尾部，每次操作的时候移动链表，但是这样的操作需要占用内存，并且消耗cpu，所以一次取5个（默认，可配置）然后删除最久没用的一个。

lfu最少使用：由于lru存在内存污染问题（某应用读取了大量key，然后又只用了一次，这样却存了很久）。额外存储一个logc值，默认是5，每次访问的时候根据上次的时间戳间隔来衰减，然后有一定概率增长。删除的时候，也是一次取5个，删除logc最小的值。



# redis集群

## 

# redis其他面试提补充

## 单点redis不够用怎么办

读写分离

分库分表；部署 Redis Cluster 集群，Redis Cluster 将数据自动划分为 16384 个槽（slots），每个槽都可以存储键值对。这些槽会被分配到多个 Redis 节点上，通过哈希函数将键映射到相应的槽，再由槽映射到具体的 Redis 节点。

## redis的一致性问题

对于读数据，我会选择旁路缓存策略，如果 cache 不命中，会从 db 加载数据到 cache。对于写数据，我会选择更新 db 后，再删除缓存

缓存是通过牺牲强一致性来提高性能的。这是由**CAP理论**决定的。缓存系统适用的场景就是非强一致性的场景，它属于CAP中的AP。所以，如果需要数据库和缓存数据保持强一致，就不适合使用缓存。

缓存为什么要设置过期时间，设置的时间长短有什么好处坏处。

太短了，缓存作用就不大了。

太长了，脏数据保存的时间就比较长。脏数据哪儿来的呢？按照上面我们的更新逻辑，删除缓存失败。

可以通过其他办法来保证最终一致性，比如重试删除。通过把删除的命令放入消息队列，消息消费失败则重新读取，超过一定次数向业务层报警；删除成功就从消息队列中删除。

### 缓存击穿 穿透 雪崩

缓存击穿：数据过期后，数据大量打到数据库里面。  热点数据永不过期;互斥锁方案，只有一个请求能请求数据库，其他的只能请求缓存。请求不到的应该返回默认值，可以为null或者 在redis中引入逻辑过期的概念，返回值旧值。

缓存穿透：当用户访问的数据，**既不在缓存中，也不在数据库中**，所以每次请求缓存后都会请求数据库。

在缓存中设置一个空的返回值；限制非法请求；过滤器，例如bulong过滤器，由点位图和多个哈希函数组成。

先查询过滤器，再查询数据。由于布隆过滤器存在哈希冲突，可能过滤器认为存在但是实际不存在。

缓存雪崩：大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库

缓存启动的预热，均匀设置过期时间，构建redis集群的稳定性（主从等）



## Redis是单线程吗？为什么

Redis 单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的。

## Redis 大key对持久化的影响

大key，多大算大？ String 10kb，或者集合超过一万个，当然这只是一个大概的数据。



浅说一下大key的危害：读写/aof时间太长，性能下降；占用内存较多；网络I/O开销；主从同步，数据恢复；

解决办法：报警监控大key；清除非必要的大key；压缩value，通过序列化，压缩算法；拆分大key；



对于持久化的影响，AOF回写会阻塞，缓存区很容易被占满；很容易出发AOF回写；对于RDB影响应该是不大的。