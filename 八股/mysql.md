# 1.基础架构

分为server层和存储引擎两部分

## server层

连接器-分析器-优化器-执行器

#### 连接器

负责跟客户端进行连接

连接成功后，权限不会被改变。太长时间未响应会自动断开。wait_timeout控制

长连接是有持续请求，一直使用同一个连接，短连接则执行几次就断开。由于建立连接的开销不小，所以推荐用长连接。

全部使用长连接可能占用内存特别快，这是因为MySQL执行过程中使用的内存是管理在连接对象里面的，断开连接时才释放。

解决方法有两种，定期断开长连接，使用5.7以上版本有mysql_reset_connection操作，可以重新初始化连接资源。

#### 查询缓存

查到缓存就可以省掉执行器等过程，但是mysql表修改后，缓存都会失效。

可以使用按需使用的方式，全局不使用缓存，对于对应的静态表进行使用缓存。

8.0后删除了这个缓存的功能

#### 分析器

对SQL语句进行解析

#### 优化器

一个语句有多种执行方案，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。

#### 执行器

执行sql语句

## 存储引擎

最常见的是InnoDB/MyISAM

5.5之前默认的是MyISAM，后续默认是innoDB

innoDB的主要优势是支持事务，支持行锁（更细粒度的锁机制），支持外键

MyISAM的优势是不考虑事务等查询更高效，支持表压缩

比较值得注意的是：索引的数据结构，日志是与存储引擎有关系的。

![截屏2025-02-12 15.35.02](images/%E6%88%AA%E5%B1%8F2025-02-12%2015.35.02.png)

# 2.索引

索引是一种提高搜索效率的工具

常见的索引

innoDB的索引

什么时候加索引/如何加索引

主键索引和非主键索引

索引什么时候会失效

如何避免/减少回表

mysql为什么会选错索引

为什么是B+树

# 3.事务

事务是用来保证一组数据的完整性和一致性

事务的性质：ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性

脏读，事物a读取了b未提交的数据

不可重复读，事物a进行的过程中数据变化了，无法重复读取。

幻读，读取时两次数据总量不一致

## 隔离性

一个基本原则，隔离的越严实，效率就会越低

4种层级 读未提交，读提交，可重复读，串行化

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。防止脏读
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。防止不可重复读和脏读，但是有幻读情况。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

不同的业务场景，需要不同的隔离程度

# 4.日志

# 5.集群

# 其他

一个解决慢SQL的实际例子